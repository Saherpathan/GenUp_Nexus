from flask import Flask, jsonify, request
from flask_cors import CORS
from pymongo.mongo_client import MongoClient
from pymongo.server_api import ServerApi
import google.generativeai as genai
import urllib.parse
from models import UserSchema
from flask_bcrypt import Bcrypt
from flask_jwt_extended import JWTManager, create_access_token
from middleware.authUser import auth_user
from datetime import timedelta 
from controllers.demo import get_initial_data
from controllers.mindmap import saveMindmap, getMindmap, deleteMindmap, getMindmapByid

from dotenv import load_dotenv
import os

load_dotenv()

app = Flask(__name__)



bcrypt = Bcrypt(app)
jwt = JWTManager(app)

app.config['JWT_SECRET_KEY'] = os.getenv('JWT_SECRET')

# MongoDB configuration
username = urllib.parse.quote_plus(os.getenv('MONGO_USERNAME'))
password = urllib.parse.quote_plus(os.getenv('MONGO_PASSWORD'))
restUri = os.getenv('REST_URI');

uri = f'mongodb+srv://{username}:{password}{restUri}'

client = MongoClient(uri, server_api=ServerApi('1'))
db = client.GenUpNexus
users_collection = db["users"]
savedMindmap = db["savedMindmap"]

# Send a ping to confirm a successful connection
try:
    client.admin.command('ping')
    print("Pinged your deployment. You successfully connected to MongoDB!")
except Exception as e:
    print(e)


GOOGLE_API_KEY=os.getenv('GOOGLE_API_KEY')

genai.configure(api_key=GOOGLE_API_KEY)
model = genai.GenerativeModel('gemini-pro')

@app.route('/')
def index():
    return "Server is Running..."

@app.route('/index')
def index2():
    return "routes checking..."

@app.route('/tree', methods=["POST", "GET"])
def tree():
    if request.method == 'POST':
        data = request.get_json()
        query = data.get('query')
        print(query)
        response = model.generate_content('''I will give you a topic and you have to generate an explanation of the topic in points in hierarchical tree structure and respond with JSON structure as follows:
        {
            "name": "Java",
            "children": [
                {
                "name": "Development Environment",
                "children": [
                    {
                    "name": "Java Source Code",
                    "value": ".java files",
                    "description": "Human-readable code written with Java syntax."
                    },
                    {
                    "name": "Java Development Kit (JDK)",
                    "children": [
                        {
                        "name": "Compiler",
                        "value": "translates to bytecode",
                        "description": "Transforms Java source code into bytecode instructions understood by the JVM."
                        },
                        {
                        "name": "Java Class Library (JCL)",
                        "value": "predefined classes and functions",
                        "description": "Provides a collection of reusable code for common functionalities."
                        }
                    ]
                    }
                ]
                },
                {
                "name": "Execution",
                "children": [
                    {
                    "name": "Java Runtime Environment (JRE)",
                    "children": [
                        {
                        "name": "Java Virtual Machine (JVM)",
                        "value": "executes bytecode",
                        "description": "Software program that interprets and executes bytecode instructions."
                        },
                        {
                        "name": "Class Loader",
                        "value": "loads bytecode into memory",
                        "description": "Loads .class files containing bytecode into JVM memory for execution."
                        }
                    ]
                    },
                    {
                    "name": "Bytecode",
                    "value": ".class files (platform-independent)",
                    "description": "Machine-independent instructions generated by the compiler, executable on any system with JVM."
                    },
                    {
                    "name": "Just-In-Time (JIT) Compilation (optional)",
                    "value": "improves performance by translating bytecode to machine code",
                    "description": "Technique that translates frequently used bytecode sections into native machine code for faster execution."
                    }
                ]
                },
                {
                "name": "Key Features",
                "children": [
                    {
                    "name": "Object-Oriented Programming",
                    "value": "uses objects and classes",
                    "description": "Programs are structured around objects that encapsulate data and behavior."
                    },
                    {
                    "name": "Platform Independent (write once, run anywhere)",
                    "value": "bytecode runs on any system with JVM",
                    "description": "Java code can be compiled once and run on any platform with a JVM installed."
                    },
                    {
                    "name": "Garbage Collection",
                    "value": "automatic memory management",
                    "description": "JVM automatically reclaims memory from unused objects, simplifying memory management for developers."
                    }
                ]
                }
            ]
            }
            Topic is: ''' + query)
        
        # print(response.text)
        return jsonify({'success': True, 'data': response.text})
        # return temp 


@app.route('/tree/demo', methods=["POST"])
def treeDemo():
    if request.method == 'POST':
        data = request.get_json()
        query = data.get('query')
        print(query)
        response = model.generate_content('''Generate a comprehensive knowledge map representing the user's query, suitable for ReactFlow visualization.

**Prompt:** {query}

**Structure:**

- Top-level node: Represent the user's query.
- Sub-nodes branching out based on the query's relevance:
    - Leverage external knowledge sources (e.g., Wikipedia, knowledge graphs, domain-specific APIs) to identify relevant sub-concepts, related entities, and potential relationships.
- Consider including different categories of sub-nodes:
    - **Concepts:** Core ideas or principles related to the query.
    - **Subfields:** Specialized areas within the main topic.
    - **Applications:** Practical uses of the concept or subfield.
    - **Tools and Technologies:** Software or platforms used to implement the concepts.
    - **Examples:** Illustrative instances or use cases.
    - **Historical Context:** Milestones or key figures in the topic's development.
    - **See Also:** Links to broader concepts or related areas for the further exploration.
    
                                          
**Content:**

- Each node should have a label describing the concept, entity, or tool.
- Include brief descriptions, definitions, or key points within the nodes or as tooltips.
- Consider using icons to visually represent different categories of nodes (e.g.üí° for concepts, ‚öôÔ∏è for tools, üìÖ for historical context, üß© for subfields).
- Also follow the n-ary tree structure for better visualization.
- There should be atmax 10 nodes.
- Ensure the knowledge map is visually appealing, well-organized, and easy to navigate.

**Desired Format:**

- JSON structure compatible with ReactFlow:
    - nodes (list): id, position, data (label, description, icon, category), type(custom).
    - edges (list): id, source, target, label(if required), animated (true or false), style (stroke).
- Keep the top level node centered and highlighted. 
- keep the position of nodes spaced out for better visualization.
- keep atleast 2 edges "animated":true.
- Strictly keep the all the nodes with type property value as custom. 
- to edit edges add style with stroke property and a hexcode value to it.
                                   
Topic is: ''' + query)
        
        # response.text(8,)
        print(response.text)
        json_data = response.text
        modified_json_data = json_data[8:-3]
        return jsonify({'success': True, 'data': modified_json_data})
        # return temp 


@app.route('/interview', methods=["POST", "GET"])
def interview():
    if request.method == 'POST':
        data = request.get_json()
        if data.get('from') == 'client':
            return "Success"
        elif data.get('from') == 'gradio':
            print(data)
            return "Success"


# User Routes
@app.route('/user/signup', methods=['POST'])
def signup():
    data = request.json
    name = data.get('name')
    email = data.get('email')
    password = data.get('password')

    if not email:
        return jsonify({"error": "Invalid email"}), 400

    existing_user = users_collection.find_one({"email": email})

    if existing_user:
        return jsonify({"message": "User already exists"}), 404

    hashed_password = bcrypt.generate_password_hash(password).decode('utf-8')

    result = users_collection.insert_one({
        "name": name,
        "email": email,
        "password": hashed_password
    })

    print(result);

    expires = timedelta(days=7)
    access_token = create_access_token(identity={"email": email, "id": str(result.inserted_id)}, expires_delta=expires)

    res = {"name": name, "email": email, "userId": str(result.inserted_id)}
    
    return jsonify({"result": res, "token": access_token}), 201

@app.route('/user/signin', methods=['POST'])
def signin():
    data = request.json
    email = data.get('email')
    password = data.get('password')

    user = users_collection.find_one({"email": email})

    if not user:
        return jsonify({"message": "User doesn't exist"}), 404

    if not bcrypt.check_password_hash(user['password'], password):
        return jsonify({"message": "Invalid Credentials"}), 404

    expires = timedelta(days=7)
    access_token = create_access_token(identity={"email": user['email'], "id": str(user['_id'])}, expires_delta=expires)

    res = {"name": user['name'], "email": user['email'], "userId": str(user['_id'])}

    return jsonify({"result": res, "token": access_token}), 200

#protected route wiht auth_user middleware
@app.route('/user/delete', methods=['POST'])
@auth_user
def delete_account():
    email = request.email
    print(email)
    try:
        result = users_collection.delete_one({"email": email})
        if result.deleted_count == 1:
            return jsonify({"result": True}), 200
        else:
            return jsonify({"result": False, "message": "User not found"}), 404
    except Exception as e:
        print(e)
        return jsonify({"message": "Something went wrong"}), 500

# mindmap routes
@app.route('/mindmap/save', methods=['POST'])
@auth_user
def mindmapSave():
    userId = request.userId
    data = request.json
    return saveMindmap(data, userId, savedMindmap)

@app.route('/mindmap/get', methods=['GET'])
@auth_user
def mindmapGet():
    userId = request.userId
    return getMindmap(userId, savedMindmap)

@app.route('/mindmap/get/<id>', methods=['GET'])
def mindmapGetById(id):
    return getMindmapByid(id, savedMindmap)

@app.route('/mindmap/delete', methods=['POST'])
@auth_user
def mindmapDelete():
    userId = request.userId
    data = request.json
    return deleteMindmap(userId, data, savedMindmap)


@app.route('/mindmap/demo', methods=['POST'])
def mindmapDemo():
    data = request.json
    print(data);
    return get_initial_data(), 200


CORS(app)

# if __name__ == '__main__':
#     app.run(debug=True)
