from flask import Flask, jsonify, request
from flask_cors import CORS
from pymongo.mongo_client import MongoClient
from pymongo.server_api import ServerApi
import google.generativeai as genai
import urllib.parse
from models import UserSchema
from flask_bcrypt import Bcrypt
from flask_jwt_extended import JWTManager, create_access_token
from middleware.authUser import auth_user
from datetime import timedelta 
from controllers.demo import get_initial_data

from dotenv import load_dotenv
import os

load_dotenv()

app = Flask(__name__)



bcrypt = Bcrypt(app)
jwt = JWTManager(app)

app.config['JWT_SECRET_KEY'] = os.getenv('JWT_SECRET')

# MongoDB configuration
username = urllib.parse.quote_plus(os.getenv('MONGO_USERNAME'))
password = urllib.parse.quote_plus(os.getenv('MONGO_PASSWORD'))
restUri = os.getenv('REST_URI');

uri = f'mongodb+srv://{username}:{password}{restUri}'

client = MongoClient(uri, server_api=ServerApi('1'))
db = client.GenUpNexus
users_collection = db["users3"]

# Send a ping to confirm a successful connection
try:
    client.admin.command('ping')
    print("Pinged your deployment. You successfully connected to MongoDB!")
except Exception as e:
    print(e)


GOOGLE_API_KEY=os.getenv('GOOGLE_API_KEY')

genai.configure(api_key=GOOGLE_API_KEY)
model = genai.GenerativeModel('gemini-pro')

@app.route('/')
def index():
    return "Server is Running..."

@app.route('/tree', methods=["POST", "GET"])
def tree():
    if request.method == 'POST':
        data = request.get_json()
        query = data.get('query')
        print(query)
        response = model.generate_content('''I will give you a topic and you have to generate an explanation of the topic in points in hierarchical tree structure and respond with JSON structure as follows:
        {
            "name": "Java",
            "children": [
                {
                "name": "Development Environment",
                "children": [
                    {
                    "name": "Java Source Code",
                    "value": ".java files",
                    "description": "Human-readable code written with Java syntax."
                    },
                    {
                    "name": "Java Development Kit (JDK)",
                    "children": [
                        {
                        "name": "Compiler",
                        "value": "translates to bytecode",
                        "description": "Transforms Java source code into bytecode instructions understood by the JVM."
                        },
                        {
                        "name": "Java Class Library (JCL)",
                        "value": "predefined classes and functions",
                        "description": "Provides a collection of reusable code for common functionalities."
                        }
                    ]
                    }
                ]
                },
                {
                "name": "Execution",
                "children": [
                    {
                    "name": "Java Runtime Environment (JRE)",
                    "children": [
                        {
                        "name": "Java Virtual Machine (JVM)",
                        "value": "executes bytecode",
                        "description": "Software program that interprets and executes bytecode instructions."
                        },
                        {
                        "name": "Class Loader",
                        "value": "loads bytecode into memory",
                        "description": "Loads .class files containing bytecode into JVM memory for execution."
                        }
                    ]
                    },
                    {
                    "name": "Bytecode",
                    "value": ".class files (platform-independent)",
                    "description": "Machine-independent instructions generated by the compiler, executable on any system with JVM."
                    },
                    {
                    "name": "Just-In-Time (JIT) Compilation (optional)",
                    "value": "improves performance by translating bytecode to machine code",
                    "description": "Technique that translates frequently used bytecode sections into native machine code for faster execution."
                    }
                ]
                },
                {
                "name": "Key Features",
                "children": [
                    {
                    "name": "Object-Oriented Programming",
                    "value": "uses objects and classes",
                    "description": "Programs are structured around objects that encapsulate data and behavior."
                    },
                    {
                    "name": "Platform Independent (write once, run anywhere)",
                    "value": "bytecode runs on any system with JVM",
                    "description": "Java code can be compiled once and run on any platform with a JVM installed."
                    },
                    {
                    "name": "Garbage Collection",
                    "value": "automatic memory management",
                    "description": "JVM automatically reclaims memory from unused objects, simplifying memory management for developers."
                    }
                ]
                }
            ]
            }
            Topic is: ''' + query)
        
        # print(response.text)
        return jsonify({'success': True, 'data': response.text})
        # return temp 


@app.route('/tree/demo', methods=["POST"])
def treeDemo():
    if request.method == 'POST':
        data = request.get_json()
        query = data.get('query')
        print(query)
        response = model.generate_content('''Generate a comprehensive knowledge map representing the user's query, suitable for ReactFlow visualization.

**Prompt:** {query}

**Structure:**

- Top-level node: Represent the user's query.
- Sub-nodes branching out based on the query's relevance:
    - Leverage external knowledge sources (e.g., Wikipedia, knowledge graphs, domain-specific APIs) to identify relevant sub-concepts, related entities, and potential relationships.
- Consider including different categories of sub-nodes:
    - **Concepts:** Core ideas or principles related to the query.
    - **Subfields:** Specialized areas within the main topic.
    - **Applications:** Practical uses of the concept or subfield.
    - **Tools and Technologies:** Software or platforms used to implement the concepts.
    - **Examples:** Illustrative instances or use cases.
    - **Historical Context:** Milestones or key figures in the topic's development.
    - **See Also:** Links to broader concepts or related areas for the further exploration.
    
                                          
**Content:**

- Each node should have a label describing the concept, entity, or tool.
- Optionally, include brief descriptions, definitions, or key points within the nodes or as tooltips.
- Consider using icons to visually represent different categories of nodes (e.g., light bulb for concepts, gear for tools, calendar for historical context, puzzle piece for subfields).

**Desired Format:**

- JSON structure compatible with ReactFlow:
    - nodes (list): Nodes with data (label, optional description, optional icon, optional category) and position.
    - edges (list): Edges connecting nodes with source and target IDs, and an optional label.


**Example:** (Providing you a simplified JSON example demonstrating the structure with nodes, edges.
        nodes = [
            {
                id: "1",
                type: "input",
                data: {
                label: "Input Node",
                },
                position: { x: 250, y: 0 },
                animated: true,
            },
            {
                id: "2",
                data: {
                label: "Default Node",
                },
                position: { x: 100, y: 100 },
                animated: true,
            },
            {
                id: "3",
                type: "output",
                data: {
                label: "Output Node",
                },
                position: { x: 400, y: 100 },
                animated: true,
            },
            {
                id: "4",
                type: "custom",
                position: { x: 100, y: 200 },
                data: {
                selects: {
                    "handle-0": "smoothstep",
                    "handle-1": "smoothstep",
                },
                animated: true,
                },
            },
            {
                id: "5",
                type: "output",
                data: {
                label: "custom style",
                },
                animated: true,
                className: "circle",
                style: {
                background: "#2B6CB0",
                color: "white",
                },
                position: { x: 400, y: 200 },
                sourcePosition: Position.Right,
                targetPosition: Position.Left,
            },
            {
                id: "6",
                type: "output",
                style: {
                background: "#63B3ED",
                color: "white",
                width: 100,
                },
                data: {
                label: "Node",
                },
                position: { x: 400, y: 325 },
                animated: true,
                sourcePosition: Position.Right,
                targetPosition: Position.Left,
            },
            {
                id: "7",
                type: "default",
                className: "annotation",
                data: {
                label: (
                    <>
                    Your mindmap! ðŸ¥³
                    </>
                ),
                },
                animated: true,
                draggable: false,
                selectable: true,
                position: { x: 150, y: 400 },
            },
            ];

            edges = [
                { id: "e1-2", source: "1", target: "2", label: "this is an edge label" },
                { id: "e1-3", source: "1", target: "3", animated: true },
                {
                    id: "e4-5",
                    source: "4",
                    target: "5",
                    type: "smoothstep",
                    sourceHandle: "handle-0",
                    data: {
                    selectIndex: 0,
                    },
                    markerEnd: {
                    type: MarkerType.ArrowClosed,
                    },
                },
                {
                    id: "e4-6",
                    source: "4",
                    target: "6",
                    type: "smoothstep",
                    sourceHandle: "handle-1",
                    data: {
                    selectIndex: 1,
                    },
                    markerEnd: {
                    type: MarkerType.ArrowClosed,
                    },
                },
            ];

            Topic is: ''' + query)
        
        # response.text(8,)
        print(response.text)
        json_data = response.text
        modified_json_data = json_data[8:-3]
        return jsonify({'success': True, 'data': modified_json_data})
        # return temp 


@app.route('/interview', methods=["POST", "GET"])
def interview():
    if request.method == 'POST':
        data = request.get_json()
        if data.get('from') == 'client':
            return "Success"
        elif data.get('from') == 'gradio':
            print(data)
            return "Success"


# User Routes
@app.route('/user/signup', methods=['POST'])
def signup():
    data = request.json
    name = data.get('name')
    email = data.get('email')
    password = data.get('password')

    if not email:
        return jsonify({"error": "Invalid email"}), 400

    existing_user = users_collection.find_one({"email": email})

    if existing_user:
        return jsonify({"message": "User already exists"}), 404

    hashed_password = bcrypt.generate_password_hash(password).decode('utf-8')

    result = users_collection.insert_one({
        "name": name,
        "email": email,
        "password": hashed_password
    })

    print(result);

    expires = timedelta(days=7)
    access_token = create_access_token(identity={"email": email, "id": str(result.inserted_id)}, expires_delta=expires)

    res = {"name": name, "email": email}
    
    return jsonify({"result": res, "token": access_token}), 201

@app.route('/user/signin', methods=['POST'])
def signin():
    data = request.json
    email = data.get('email')
    password = data.get('password')

    user = users_collection.find_one({"email": email})

    if not user:
        return jsonify({"message": "User doesn't exist"}), 404

    if not bcrypt.check_password_hash(user['password'], password):
        return jsonify({"message": "Invalid Credentials"}), 404

    expires = timedelta(days=7)
    access_token = create_access_token(identity={"email": user['email'], "id": str(user['_id'])}, expires_delta=expires)

    res = {"name": user['name'], "email": user['email']}

    return jsonify({"result": res, "token": access_token}), 200

#protected route wiht auth_user middleware
@app.route('/user/delete', methods=['POST'])
@auth_user
def delete_account():
    email = request.email
    print(email)
    try:
        result = users_collection.delete_one({"email": email})
        if result.deleted_count == 1:
            return jsonify({"result": True}), 200
        else:
            return jsonify({"result": False, "message": "User not found"}), 404
    except Exception as e:
        print(e)
        return jsonify({"message": "Something went wrong"}), 500

@app.route('/mindmap/demo', methods=['POST'])
def mindmapDemo():
    data = request.json
    print(data);
    return get_initial_data(), 200




CORS(app)

if __name__ == '__main__':
    app.run(debug=True)